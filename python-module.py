#!/usr/local/bin/python3.6

import sys

print('命令行参数如下:')

for i in sys.argv:
    print(i)


print()
print("Python3.6 的路径为： ", sys.path)

print("1、import sys 引入 python 标准库中的 sys.py 模块；这是引入某一模块的方法。")
print("2、sys.argv 是一个包含命令行参数的列表。")
print("3、sys.path 包含了一个 Python 解释器自动查找所需模块的路径的列表。")

print("import 语句")

print("想使用 Python 源文件，只需在另一个源文件里执行 import 语句")

print("import module1[, module2[,... moduleN]")

print("解释器遇到 import 语句，如果模块在当前的搜索路径就会被导入。")

print("搜索路径是一个解释器会先进行搜索的所有目录的列表。")

print("一个模块只会被导入一次，不管你执行了多少次import。这样可以防止导入模块被一遍又一遍地执行")
print("当我们使用import语句的时候，Python解释器是怎样找到对应的文件的呢?")
print("这就涉及到Python的搜索路径，搜索路径是由一系列目录名组成的，Python解释器就依次从这些目录中去寻找所引入的模块")
print("这看起来很像环境变量，事实上，也可以通过定义环境变量的方式来确定搜索路径。")
print("搜索路径是在Python编译或安装的时候确定的，安装新的库应该也会修改。搜索路径被存储在sys模块中的path变量")
print("sys.path 输出是一个列表，其中第一项是空串''，代表当前目录（若是从一个脚本中打印出来的话，可以更清楚地看出是哪个目录），亦即我们执行python解释器的目录（对于脚本的话就是运行的脚本所在的目录）")

print("")

print("from…import 语句")
print("Python的from语句让你从模块中导入一个指定的部分到当前命名空间中")
print("")
print("From…import* 语句")
print("把一个模块的所有内容全都导入到当前的命名空间也是可行的")

print("深入模块")

print("模块除了方法定义，还可以包括可执行的代码。这些代码一般用来初始化这个模块。这些代码只有在第一次被导入时才会被执行。")
print("每个模块有各自独立的符号表，在模块内部为所有的函数当作全局符号表来使用。")
print("所以，模块的作者可以放心大胆的在模块内部使用这些全局变量，而不用担心把其他用户的全局变量搞花。")
print("从另一个方面，当你确实知道你在做什么的话，你也可以通过 modname.itemname 这样的表示法来访问模块内的函数。")
print("模块是可以导入其他模块的。在一个模块（或者脚本，或者其他地方）的最前面使用 import 来导入一个模块，当然这只是一个惯例，而不是强制的。被导入的模块的名称将被放入当前操作的模块的符号表中。")
print("还有一种导入的方法，可以使用 import 直接把模块内（函数，变量的）名称导入到当前操作模块")
print("如： from fibo import fib, fib2")

print("__name__属性")
print("一个模块被另一个程序第一次引入时，其主程序将运行。如果我们想在模块被引入时，模块中的某一程序块不执行，我们可以用__name__属性来使该程序块仅在该模块自身运行时执行")

if __name__ == '__main__':
    print("程序自身运行")

else:
    print("其他模块")


print("dir() 函数")
print("内置的函数 dir() 可以找到模块内定义的所有名称。以一个字符串列表的形式返回")
print("")
print("dir(sys) ", dir(sys))

print("")
print("标准模块")
print("Python 本身带着一些标准的模块库")
print("有些模块直接被构建在解析器里，这些虽然不是一些语言内置的功能，但是他却能很高效的使用，甚至是系统级调用也没问题。")
print("这些组件会根据不同的操作系统进行不同形式的配置，比如 winreg 这个模块就只会提供给 Windows 系统")
print("应该注意到这有一个特别的模块 sys ，它内置在每一个 Python 解析器中。变量 sys.ps1 和 sys.ps2 定义了主提示符和副提示符所对应的字符串")

print("")
print("包")
print("包是一种管理 Python 模块命名空间的形式，采用'点模块名称'")
print("比如一个模块的名称是 A.B， 那么他表示一个包 A中的子模块 B 。")
print("就好像使用模块的时候，你不用担心不同模块之间的全局变量相互影响一样，采用点模块名称这种形式也不用担心不同库之间的模块重名的情况。")
print("这样不同的作者都可以提供 NumPy 模块，或者是 Python 图形库")
print("在导入一个包的时候，Python 会根据 sys.path 中的目录来寻找这个包中包含的子目录。")
print("目录只有包含一个叫做 __init__.py 的文件才会被认作是一个包，主要是为了避免一些滥俗的名字（比如叫做 string）不小心的影响搜索路径中的有效模块。")
print("最简单的情况，放一个空的 :file:__init__.py就可以了。当然这个文件中也可以包含一些初始化代码或者为（将在后面介绍的） __all__变量赋值。")
print("")
print("")
